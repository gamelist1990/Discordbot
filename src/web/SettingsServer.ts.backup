import express, { Express, Request, Response } from 'express';
import cors from 'cors';
import path from 'path';
import { Logger } from '../utils/Logger.js';
import { BotClient } from '../core/BotClient.js';
import { SessionService } from './services/SessionService.js';
import { createStatusRoutes, createSessionRoutes, createSettingsRoutes, createStaffRoutes } from './routes/index.js';

// å‹å®šç¾©ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export { SettingsSession, GuildSettings } from './types/index.js';

/**
 * è¨­å®šç”»é¢ç”¨Webã‚µãƒ¼ãƒãƒ¼ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹é€ ï¼‰
 */
export class SettingsServer {
    private app: Express;
    private port: number;
    private sessionService: SessionService;
    private botClient: BotClient;
    private server: any;

    constructor(botClient: BotClient, port: number = 3000) {
        this.app = express();
        this.port = port;
        this.sessionService = new SessionService();
        this.botClient = botClient;

        this.setupMiddleware();
        this.setupRoutes();
    }

    /**
     * ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®è¨­å®š
     */
    private setupMiddleware(): void {
        this.app.use(cors());
        this.app.use(express.json());
        this.app.use(express.static(path.join(__dirname, '..', '..', 'dist', 'web')));
    }

    /**
     * ãƒ«ãƒ¼ãƒˆã®è¨­å®šï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ï¼‰
     */
    private setupRoutes(): void {
        const sessions = this.sessionService.getSessions();

        // APIãƒ«ãƒ¼ãƒˆã‚’ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
        this.app.use('/api', createStatusRoutes(this.botClient));
        this.app.use('/api', createSessionRoutes(sessions, this.botClient));
        this.app.use('/api', createSettingsRoutes(sessions));
        this.app.use('/api/staff', createStaffRoutes(sessions, this.botClient));

        // SPAã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã™ã¹ã¦ã®éAPIãƒ«ãƒ¼ãƒˆã‚’index.htmlã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆï¼‰
        this.app.use((_req: Request, res: Response) => {
            const indexPath = path.join(__dirname, '..', '..', 'dist', 'web', 'index.html');
            res.sendFile(indexPath);
        });
    }

    /**
     * Bot ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å–å¾—
     */
    private async handleGetStatus(_req: Request, res: Response): Promise<void> {
        try {
            const status = statusManager.getStatus();
            const guildCount = this.botClient.getGuildCount();
            const maxGuilds = this.botClient.getMaxGuilds();

            res.json({
                ...status,
                guildCount,
                maxGuilds,
                uptimeFormatted: this.formatUptime(status.uptime),
            });
        } catch (error) {
            Logger.error('ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            res.status(500).json({ error: 'Failed to fetch status' });
        }
    }

    /**
     * ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
     */
    private formatUptime(ms: number): string {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}æ—¥ ${hours % 24}æ™‚é–“ ${minutes % 60}åˆ†`;
        } else if (hours > 0) {
            return `${hours}æ™‚é–“ ${minutes % 60}åˆ†`;
        } else if (minutes > 0) {
            return `${minutes}åˆ† ${seconds % 60}ç§’`;
        } else {
            return `${seconds}ç§’`;
        }
    }

    /**
     * ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
     */
    private async handleValidateToken(req: Request, res: Response): Promise<void> {
        const { token } = req.params;

        const session = this.sessions.get(token);
        if (!session) {
            res.status(404).json({ valid: false, error: 'Session not found' });
            return;
        }

        if (Date.now() > session.expiresAt) {
            this.sessions.delete(token);
            res.status(401).json({ valid: false, error: 'Session expired' });
            return;
        }

        res.json({ valid: true, guildId: session.guildId, userId: session.userId });
    }

    /**
     * ã‚®ãƒ«ãƒ‰æƒ…å ±ã®å–å¾—
     */
    private async handleGetGuild(req: Request, res: Response): Promise<void> {
        const { token } = req.params;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const guild = await this.botClient.client.guilds.fetch(session.guildId);
            const roles = await guild.roles.fetch();

            res.json({
                id: guild.id,
                name: guild.name,
                iconURL: guild.iconURL(),
                roles: roles.map(role => ({
                    id: role.id,
                    name: role.name,
                    color: role.color,
                    position: role.position,
                })).filter(r => r.id !== guild.id) // @everyone ã‚’é™¤å¤–
            });
        } catch (error) {
            Logger.error('ã‚®ãƒ«ãƒ‰æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
            res.status(500).json({ error: 'Failed to fetch guild information' });
        }
    }

    /**
     * è¨­å®šã®å–å¾—
     */
    private async handleGetSettings(req: Request, res: Response): Promise<void> {
        const { token } = req.params;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const settings = await database.get<GuildSettings>(`guild_settings_${session.guildId}`);

            res.json(settings || {
                guildId: session.guildId,
                staffRoleId: null,
                adminRoleId: null,
                updatedAt: Date.now(),
            });
        } catch (error) {
            Logger.error('è¨­å®šã®å–å¾—ã«å¤±æ•—:', error);
            res.status(500).json({ error: 'Failed to fetch settings' });
        }
    }

    /**
     * è¨­å®šã®ä¿å­˜
     */
    private async handleSaveSettings(req: Request, res: Response): Promise<void> {
        const { token } = req.params;
        const { staffRoleId, adminRoleId } = req.body;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const settings: GuildSettings = {
                guildId: session.guildId,
                staffRoleId: staffRoleId || undefined,
                adminRoleId: adminRoleId || undefined,
                updatedAt: Date.now(),
            };

            await database.set(`guild_settings_${session.guildId}`, settings);

            Logger.info(`è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ: Guild=${session.guildId}, Staff=${staffRoleId}, Admin=${adminRoleId}`);
            res.json({ success: true });
        } catch (error) {
            Logger.error('è¨­å®šã®ä¿å­˜ã«å¤±æ•—:', error);
            res.status(500).json({ error: 'Failed to save settings' });
        }
    }

    /**
     * ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä½œæˆ
     */
    public createSession(guildId: string, userId: string): string {
        const token = randomUUID();
        const expiresIn = 30 * 60 * 1000; // 30åˆ†

        const session: SettingsSession = {
            token,
            guildId,
            userId,
            createdAt: Date.now(),
            expiresAt: Date.now() + expiresIn,
        };

        this.sessions.set(token, session);

        // æœŸé™åˆ‡ã‚Œã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è‡ªå‹•å‰Šé™¤
        setTimeout(() => {
            this.sessions.delete(token);
            Logger.debug(`ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒæœŸé™åˆ‡ã‚Œã«ãªã‚Šã¾ã—ãŸ: ${token}`);
        }, expiresIn);

        Logger.info(`æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ä½œæˆã—ã¾ã—ãŸ: Token=${token}, Guild=${guildId}, User=${userId}`);
        return token;
    }

    /**
     * ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•
     */
    public async start(): Promise<void> {
        return new Promise((resolve, reject) => {
            try {
                this.server = this.app.listen(this.port, () => {
                    Logger.info(`ğŸŒ è¨­å®šã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¾ã—ãŸ: http://localhost:${this.port}`);
                    resolve();
                });

                this.server.on('error', (error: Error) => {
                    Logger.error('è¨­å®šã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—:', error);
                    reject(error);
                });
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * ã‚µãƒ¼ãƒãƒ¼ã®åœæ­¢
     */
    public async stop(): Promise<void> {
        return new Promise((resolve) => {
            if (this.server) {
                this.server.close(() => {
                    Logger.info('è¨­å®šã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ');
                    resolve();
                });
            } else {
                resolve();
            }
        });
    }

    /**
     * ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆä¸€è¦§ã®å–å¾—
     */
    private async handleGetPrivateChats(req: Request, res: Response): Promise<void> {
        const { token } = req.params;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const { PrivateChatManager } = await import('../commands/staff/PrivateChatManager.js');
            const chats = await PrivateChatManager.getChatsByGuild(session.guildId);
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ä»˜åŠ 
            const guild = this.botClient.client.guilds.cache.get(session.guildId);
            const enrichedChats = await Promise.all(
                chats.map(async (chat) => {
                    const user = await guild?.members.fetch(chat.userId).catch(() => null);
                    const staff = await guild?.members.fetch(chat.staffId).catch(() => null);
                    const channel = guild?.channels.cache.get(chat.channelId);
                    
                    return {
                        ...chat,
                        userName: user?.user.username || 'Unknown User',
                        staffName: staff?.user.username || 'Unknown Staff',
                        channelExists: !!channel
                    };
                })
            );

            res.json({ chats: enrichedChats });
        } catch (error) {
            Logger.error('ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            res.status(500).json({ error: 'Failed to fetch private chats' });
        }
    }

    /**
     * ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆã®ä½œæˆ
     */
    private async handleCreatePrivateChat(req: Request, res: Response): Promise<void> {
        const { token } = req.params;
        const { userId } = req.body;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        if (!userId) {
            res.status(400).json({ error: 'userId is required' });
            return;
        }

        try {
            const guild = this.botClient.client.guilds.cache.get(session.guildId);
            if (!guild) {
                res.status(404).json({ error: 'Guild not found' });
                return;
            }

            const { PrivateChatManager } = await import('../commands/staff/PrivateChatManager.js');
            const chat = await PrivateChatManager.createChat(guild, userId, session.userId);

            Logger.info(`ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆä½œæˆ: ${chat.chatId} (User: ${userId}, Staff: ${session.userId})`);
            res.json({ success: true, chat });
        } catch (error) {
            Logger.error('ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆä½œæˆã‚¨ãƒ©ãƒ¼:', error);
            const errorMessage = error instanceof Error ? error.message : 'Failed to create private chat';
            res.status(500).json({ error: errorMessage });
        }
    }

    /**
     * ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆã®å‰Šé™¤
     */
    private async handleDeletePrivateChat(req: Request, res: Response): Promise<void> {
        const { token, chatId } = req.params;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const guild = this.botClient.client.guilds.cache.get(session.guildId);
            if (!guild) {
                res.status(404).json({ error: 'Guild not found' });
                return;
            }

            const { PrivateChatManager } = await import('../commands/staff/PrivateChatManager.js');
            const deleted = await PrivateChatManager.deleteChat(guild, chatId);

            if (deleted) {
                Logger.info(`ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆå‰Šé™¤: ${chatId}`);
                res.json({ success: true });
            } else {
                res.status(404).json({ error: 'Chat not found' });
            }
        } catch (error) {
            Logger.error('ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
            res.status(500).json({ error: 'Failed to delete private chat' });
        }
    }

    /**
     * ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆçµ±è¨ˆã®å–å¾—
     */
    private async handleGetPrivateChatStats(req: Request, res: Response): Promise<void> {
        const { token } = req.params;

        const session = this.sessions.get(token);
        if (!session || Date.now() > session.expiresAt) {
            res.status(401).json({ error: 'Invalid or expired session' });
            return;
        }

        try {
            const { PrivateChatManager } = await import('../commands/staff/PrivateChatManager.js');
            const stats = await PrivateChatManager.getStats(session.guildId);

            res.json(stats);
        } catch (error) {
            Logger.error('çµ±è¨ˆæƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            res.status(500).json({ error: 'Failed to fetch stats' });
        }
    }
}
